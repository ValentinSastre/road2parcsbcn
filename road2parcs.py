# -*- coding: utf-8 -*-
"""
/***************************************************************************
 Road2ParcsBCN
                                 A QGIS plugin
 Arriba al teu parc més proper de manera còmoda, neta i ràpida
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2020-05-18
        git sha              : $Format:%H$
        copyright            : (C) 2020 by Valentín Sastre Calvi
        email                : vsastrecalvi@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from PyQt5.QtCore import *
from PyQt5.QtGui import *
from PyQt5.QtWidgets import *
from PyQt5.QtSql import *
from qgis.gui import QgsMapTool
from qgis.core import *
from qgis.gui import QgsMapToolEmitPoint
from qgis.utils import iface
from qgis.analysis import QgsNativeAlgorithms
import processing
from datetime import datetime


# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .road2parcs_dialog import Road2ParcsBCNDialog
import os.path


class Road2ParcsBCN:

    conectardb = {}

    def __init__(self, iface):
        
        self.iface = iface
        self.plugin_dir = os.path.dirname(__file__)
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'Road2ParcsBCN_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        self.actions = []
        self.menu = self.tr(u'&Road2ParcsBCN')
        self.first_start = None


    def tr(self, message):
        return QCoreApplication.translate('Road2ParcsBCN', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):

        self.dlg = Road2ParcsBCNDialog()
        
        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):

        icon_path = ':/plugins/road2parcs/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'Calcula la ruta òptima al teu parc més proper'),
            callback=self.run,
            parent=self.iface.mainWindow())

        #### ACCIONS A EXECUTAR EN FER CLIC EN BOTONS ####
        self.dlg.sel_punt_inici.clicked.connect(self.puntinici)
        self.dlg.calcula_ruta.clicked.connect(self.calcularuta)
        self.dlg.progres.setValue(0)


    def unload(self):
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&Road2ParcsBCN'),
                action)
            self.iface.removeToolBarIcon(action)


    def run(self):
        self.dlg.show()
        self.conectardb = self.conectadb()
        self.missatge(self.tr(u'Connectat a la base de dades.'), 'Informació')

        if self.first_start == True:
            self.first_start = False
            self.dlg = Road2ParcsBCNDialog()

        result = self.dlg.exec_()
        if result:
            pass

    def missatge(self,t,title="Error"):
        m = QMessageBox()
        if title != 'Error':
            m.setIcon(QMessageBox.Information)
        else:
            m.setIcon(QMessageBox.Warning)
        m.setWindowTitle(title)
        m.setText(t)
        m.setStandardButtons(QMessageBox.Ok)
        m.exec_()

    def conectadb(self):
        params = []
        currentpath = os.path.dirname(__file__)
        currentpath = currentpath + '\\'
        arxiu = open(currentpath + 'config.txt', 'r')
        for row in arxiu:
            params.append(row.replace('\n','').split('=')[1])
        arxiu.close()
        params[3] = int(params[3])

        db = QSqlDatabase.addDatabase(params[0])
        db.setHostName(params[1]) 
        db.setDatabaseName(params[2])
        db.setPort(params[3]) 
        db.setUserName(params[4]) 
        db.setPassword(params[5]) 
        db.open()
        if db.isOpen():
            print('Connexió feta')
            #self.missatge(self.tr(u'Connectat a la base de dades\nBase de dades: {} '.format(params[2])),'Informació')
        else:
            db.close()
            self.missatge(self.tr(u"Error en connectar a la base de dades!\n")+db.lastError().text())
        return db

    def getCoords(self, point, mousebutton):
        x = point.x()
        y = point.y()
        coords = str(x)+","+str(y)+" [EPSG:25831]"
        self.missatge(self.tr("Punt de partida seleccionat: "+coords),'Info')
        self.dlg.punt_partida.setText(coords)

    def puntinici(self):
        self.canvas = self.iface.mapCanvas()
        self.pointtool = QgsMapToolEmitPoint(self.canvas)
        self.pointtool.canvasClicked.connect(self.getCoords)
        self.canvas.setMapTool( self.pointtool )
        
    def calcularuta(self):
        #Consulta per a extreure només els trams vials vàlids
        pendent_max = str(self.dlg.pendent_max.value())
        max_no2 = str(self.dlg.max_no2.value())
        max_pm10 = str(self.dlg.max_pm10.value())
        cons_seltram = "(SELECT * FROM grafvial_trams WHERE cont_no2 <= "+max_no2+" AND cont_pm10 <= "+max_pm10+" AND pendent <= "+pendent_max+")"
        self.dlg.progres.setValue(6)

        #Connexió a la bbdd per a executar la consulta
        params = []
        currentpath = os.path.dirname(__file__)
        currentpath = currentpath + '\\'
        arxiu = open(currentpath + 'config.txt', 'r')
        for row in arxiu:
            params.append(row.replace('\n','').split('=')[1])
        arxiu.close()
        params[3] = int(params[3])

        nombd = params[2]
        hostbd = params[1]
        portbd = params[3]
        usuaribd = params[4]
        contrasenyabd = params[5]
        
        #Obtenció de capa de trams vàlids
        sql = cons_seltram
        uri = QgsDataSourceUri()
        uri.setConnection(hostbd, str(portbd), nombd, usuaribd, contrasenyabd)
        uri.setDataSource("",sql,"geom","","id")
            # TRAMS VALIDS
        xarxa = QgsVectorLayer(uri.uri(),"trams_aptes","postgres")

        subset1 = "(SELECT DISTINCT ON (parcs_jardins.id) parcs_jardins.* FROM parcs_jardins, grafvial_trams WHERE ST_Intersects(parcs_jardins.geom,ST_Buffer(grafvial_trams.geom,50)) AND grafvial_trams.pendent <="+pendent_max+" AND grafvial_trams.cont_no2 <="+max_no2+" AND grafvial_trams.cont_pm10 <="+max_pm10+")"
        uri.setDataSource("",subset1,"geom","","id")
        jardins = QgsVectorLayer(uri.uri(),"jardins","postgres")

        self.dlg.progres.setValue(9)

        subset2 = "(SELECT DISTINCT ON (bicing.id) bicing.* FROM bicing, grafvial_trams WHERE ST_Intersects(bicing.geom,ST_Buffer(grafvial_trams.geom,50)) AND grafvial_trams.pendent <="+pendent_max+" AND grafvial_trams.cont_no2 <="+max_no2+" AND grafvial_trams.cont_pm10 <="+max_pm10+")"
        uri.setDataSource("",subset2,"geom","","id")
        bicing = QgsVectorLayer(uri.uri(),"bicing","postgres")

        self.dlg.progres.setValue(14)

        db = self.conectadb()
        query = QSqlQuery(db)
        uri = "dbname='projectegis' host='localhost' port='5432' user='postgres' password='' key=id type=LINESTRING table=\"public\".\"jardins_aptes\" (geom) sql="
        error = QgsVectorLayerExporter.exportLayer(
            jardins,
            uri,
            "postgres",
            QgsCoordinateReferenceSystem(),
            False)

        db = self.conectadb()
        query = QSqlQuery(db)
        uri = "dbname='projectegis' host='localhost' port='5432' user='postgres' password='' key=id type=LINESTRING table=\"public\".\"bicing_aptes\" (geom) sql="
        error = QgsVectorLayerExporter.exportLayer(
            bicing,
            uri,
            "postgres",
            QgsCoordinateReferenceSystem(),
            False)

        #QgsProject.instance().addMapLayer(jardins)
        #QgsProject.instance().addMapLayer(bicing)

        punt_inici = self.dlg.punt_partida.text()

        feedback = QgsProcessingFeedback()

        self.dlg.progres.setValue(18)
        
        if self.dlg.metode_transport.currentText() == 'En bicicleta':
            try:              
                totscamins = processing.run("native:shortestpathpointtolayer",{'DEFAULT_DIRECTION':2,'DEFAULT_SPEED':2,'DIRECTION_FIELD':None,'END_POINTS':bicing,'INPUT':xarxa,'SPEED_FIELD':None,'START_POINT':punt_inici,'STRATEGY':0,'TOLERANCE':0,'VALUE_BACKWARD':'','VALUE_BOTH':'','VALUE_FORWARD':'','OUTPUT':'memory:Rutes'},feedback=feedback)['OUTPUT']
                #QgsProject.instance().addMapLayer(totscamins)
                db = self.conectadb()
                query = QSqlQuery(db)
                uri = "dbname='projectegis' host='localhost' port='5432' user='postgres' password='' key=id type=LINESTRING table=\"public\".\"temporal\" (geom) sql="
                error = QgsVectorLayerExporter.exportLayer(
                    totscamins,
                    uri,
                    "postgres",
                    QgsCoordinateReferenceSystem(),
                    False)

                self.dlg.progres.setValue(31)

                selmin = '(SELECT * FROM temporal WHERE cost = (SELECT MIN(cost) FROM temporal) LIMIT 1)'
                sql = selmin
                uri = QgsDataSourceUri()
                uri.setConnection(hostbd, str(portbd), nombd, usuaribd, contrasenyabd)
                uri.setDataSource("",sql,"geom","","id")
                tram_a_peu_1 = QgsVectorLayer(uri.uri(),"tram_a_peu_1","postgres")

                self.dlg.progres.setValue(37)

                #QgsProject.instance().addMapLayer(tram_a_peu_1)
                    
                puntbicing1 = '(SELECT id,ST_EndPoint(geom) AS "geom" FROM temporal WHERE cost = (SELECT MIN(cost) FROM temporal) LIMIT 1)'
                sql = puntbicing1
                uri.setDataSource("",sql,"geom","","id")
                estacio_bicing_1 = QgsVectorLayer(uri.uri(),"estacio_bicing_1","postgres")

                for item in estacio_bicing_1.getFeatures():
                    geometry = item.geometry()
                    coordinate = geometry.asPoint()
                    bcng_x = coordinate[0]
                    bcng_y = coordinate[1]

                est_bcng = str(bcng_x)+","+str(bcng_y)+" [EPSG:25831]"

                self.dlg.progres.setValue(40)
                
                totscamins_2 = processing.run("native:shortestpathpointtolayer",{'DEFAULT_DIRECTION':2,'DEFAULT_SPEED':20,'DIRECTION_FIELD':None,'END_POINTS':jardins,'INPUT':xarxa,'SPEED_FIELD':None,'START_POINT':est_bcng,'STRATEGY':0,'TOLERANCE':0,'VALUE_BACKWARD':'','VALUE_BOTH':'','VALUE_FORWARD':'','OUTPUT':'memory:Rutes'},feedback=feedback)['OUTPUT']
                uri = "dbname='projectegis' host='localhost' port='5432' user='postgres' password='' key=id type=LINESTRING table=\"public\".\"temporal2\" (geom) sql="
                error = QgsVectorLayerExporter.exportLayer(
                    totscamins_2,
                    uri,
                    "postgres",
                    QgsCoordinateReferenceSystem(),
                    False)

                self.dlg.progres.setValue(54)

                selmin = '(SELECT * FROM temporal2 WHERE cost = (SELECT MIN(cost) FROM temporal2) LIMIT 1)'
                sql = selmin
                uri = QgsDataSourceUri()
                uri.setConnection(hostbd, str(portbd), nombd, usuaribd, contrasenyabd)
                uri.setDataSource("",sql,"geom","","id")
                tram_bici_aux = QgsVectorLayer(uri.uri(),"tram_bici_aux","postgres")

                parcdesti = '(SELECT id,ST_EndPoint(geom) AS "geom" FROM temporal2 WHERE cost = (SELECT MIN(cost) FROM temporal2) LIMIT 1)'
                sql = parcdesti
                uri.setDataSource("",sql,"geom","","id")
                parc_desti = QgsVectorLayer(uri.uri(),"parc_desti","postgres")

                for item in parc_desti.getFeatures():
                    geometry = item.geometry()
                    coordinate = geometry.asPoint()
                    parc_x = coordinate[0]
                    parc_y = coordinate[1]

                parc_dest = str(parc_x)+","+str(parc_y)+" [EPSG:25831]"

                self.dlg.progres.setValue(61)
                
                totscamins_3 = processing.run("native:shortestpathpointtolayer",{'DEFAULT_DIRECTION':2,'DEFAULT_SPEED':2,'DIRECTION_FIELD':None,'END_POINTS':bicing,'INPUT':xarxa,'SPEED_FIELD':None,'START_POINT':parc_dest,'STRATEGY':0,'TOLERANCE':0,'VALUE_BACKWARD':'','VALUE_BOTH':'','VALUE_FORWARD':'','OUTPUT':'memory:Rutes'},feedback=feedback)['OUTPUT']
                uri = "dbname='projectegis' host='localhost' port='5432' user='postgres' password='' key=id type=LINESTRING table=\"public\".\"temporal3\" (geom) sql="
                error = QgsVectorLayerExporter.exportLayer(
                    totscamins_3,
                    uri,
                    "postgres",
                    QgsCoordinateReferenceSystem(),
                    False)

                self.dlg.progres.setValue(72)

                selmin = '(SELECT * FROM temporal3 WHERE cost = (SELECT MIN(cost) FROM temporal3) LIMIT 1)'
                sql = selmin
                uri = QgsDataSourceUri()
                uri.setConnection(hostbd, str(portbd), nombd, usuaribd, contrasenyabd)
                uri.setDataSource("",sql,"geom","","id")
                tram_a_peu_2 = QgsVectorLayer(uri.uri(),"tram_a_peu_2","postgres")
                
                #QgsProject.instance().addMapLayer(tram_a_peu_2)
                self.dlg.progres.setValue(80)

                bcngdesti = '(SELECT id,ST_GeomFromText(\'POINT(split_part(end,\', \',1),split_part(end,\', \',2)\', 25831 ) AS "geom" FROM temporal3 WHERE cost = (SELECT MIN(cost) FROM temporal3) LIMIT 1)'
                sql = parcdesti
                uri.setDataSource("",sql,"geom","","id")
                bcng_desti = QgsVectorLayer(uri.uri(),"bcng_desti","postgres")

                for item in bcng_desti.getFeatures():
                    geometry = item.geometry()
                    coordinate = geometry.asPoint()
                    bcng2_x = coordinate[0]
                    bcng2_y = coordinate[1]

                bcng_dest = str(bcng2_x)+","+str(bcng2_y)+" [EPSG:25831]"

                #QgsProject.instance().addMapLayer(estacio_bicing_1)
                #QgsProject.instance().addMapLayer(bcng_desti) 

                cami_bici = processing.run("native:shortestpathpointtopoint",{'DEFAULT_DIRECTION':2,'DEFAULT_SPEED':20,'DIRECTION_FIELD':None,'END_POINT':bcng_dest,'INPUT':xarxa,'SPEED_FIELD':None,'START_POINT':est_bcng,'STRATEGY':0,'TOLERANCE':0,'VALUE_BACKWARD':'','VALUE_BOTH':'','VALUE_FORWARD':'','OUTPUT':'memory:tram_en_bici'},feedback=feedback)['OUTPUT']

                self.dlg.progres.setValue(88)
                
                now = datetime.now()
                ct = now.strftime("%d%m%Y_%H%M%S")
                #QgsProject.instance().addMapLayer(cami_bici)            
                _writer1 = QgsVectorFileWriter.writeAsVectorFormat(tram_a_peu_1, "C:/temp/tramapeu1_"+ct+".shp",'utf-8',driverName='ESRI Shapefile')
                _writer2 = QgsVectorFileWriter.writeAsVectorFormat(tram_a_peu_2, "C:/temp/tramapeu2_"+ct+".shp",'utf-8',driverName='ESRI Shapefile')
                _writer3 = QgsVectorFileWriter.writeAsVectorFormat(cami_bici, "C:/temp/camibici_"+ct+".shp",'utf-8',driverName='ESRI Shapefile')

                result1 = iface.addVectorLayer("C:/temp/tramapeu1_"+ct+".shp", "TRAM A PEU 1", "ogr")
                result2 = iface.addVectorLayer("C:/temp/tramapeu2_"+ct+".shp", "TRAM A PEU 2", "ogr")
                result3 = iface.addVectorLayer("C:/temp/camibici_"+ct+".shp", "TRAM EN BICICLETA", "ogr")

                symbol_peu = QgsLineSymbol.createSimple({'line_style':'dash','color':'black','width':'0.6'})
                symbol_bici = QgsLineSymbol.createSimple({'color':'blue','width':'1.2'})

                result1.renderer().setSymbol(symbol_peu)
                result2.renderer().setSymbol(symbol_peu)
                result3.renderer().setSymbol(symbol_bici)

                result1.triggerRepaint()
                result2.triggerRepaint()
                result3.triggerRepaint()

                self.dlg.progres.setValue(100)

                consulta = 'DROP TABLE temporal;'
                if query.exec_(consulta) == 0:
                    self.missatge(self.tr(u"Error en eliminar la taula temporal\n")+query.lastError().text())
                    return

                consulta = 'DROP TABLE temporal2;'
                if query.exec_(consulta) == 0:
                    self.missatge(self.tr(u"Error en eliminar la taula temporal2\n")+query.lastError().text())
                    return

                consulta = 'DROP TABLE temporal3;'
                if query.exec_(consulta) == 0:
                    self.missatge(self.tr(u"Error en eliminar la taula temporal3\n")+query.lastError().text())

                consulta = 'DROP TABLE bicing_aptes;'
                if query.exec_(consulta) == 0:
                    self.missatge(self.tr(u"Error en eliminar la taula bicing_aptes\n")+query.lastError().text())

                consulta = 'DROP TABLE jardins_aptes;'
                if query.exec_(consulta) == 0:
                    self.missatge(self.tr(u"Error en eliminar la taula jardins_aptes\n")+query.lastError().text())

            except:
                self.dlg.progres.setValue(0)
                self.missatge(self.tr(u"No existeix una ruta possible. Possiblement el punt d'inici es troba a una zona d'altes emissions.\nProveu a canviar els paràmetres de contaminació."),'Error')

        if self.dlg.metode_transport.currentText() == 'A peu':
            try:              
                totscamins = processing.run("native:shortestpathpointtolayer",{'DEFAULT_DIRECTION':2,'DEFAULT_SPEED':2,'DIRECTION_FIELD':None,'END_POINTS':jardins,'INPUT':xarxa,'SPEED_FIELD':None,'START_POINT':punt_inici,'STRATEGY':0,'TOLERANCE':0,'VALUE_BACKWARD':'','VALUE_BOTH':'','VALUE_FORWARD':'','OUTPUT':'memory:Rutes'},feedback=feedback)['OUTPUT']
                #QgsProject.instance().addMapLayer(totscamins)
                db = self.conectadb()
                query = QSqlQuery(db)
                uri = "dbname='projectegis' host='localhost' port='5432' user='postgres' password='' key=id type=LINESTRING table=\"public\".\"temporal\" (geom) sql="
                error = QgsVectorLayerExporter.exportLayer(
                    totscamins,
                    uri,
                    "postgres",
                    QgsCoordinateReferenceSystem(),
                    False)

                self.dlg.progres.setValue(31)

                selmin = '(SELECT * FROM temporal WHERE cost = (SELECT MIN(cost) FROM temporal) LIMIT 1)'
                sql = selmin
                uri = QgsDataSourceUri()
                uri.setConnection(hostbd, str(portbd), nombd, usuaribd, contrasenyabd)
                uri.setDataSource("",sql,"geom","","id")
                tram_a_peu = QgsVectorLayer(uri.uri(),"tram_a_peu","postgres")

                self.dlg.progres.setValue(37)

                now = datetime.now()
                ct = now.strftime("%d%m%Y_%H%M%S")         
                _writer = QgsVectorFileWriter.writeAsVectorFormat(tram_a_peu, "C:/temp/camiapeu_"+ct+".shp",'utf-8',driverName='ESRI Shapefile')
                result = iface.addVectorLayer("C:/temp/camiapeu_"+ct+".shp", "CAMÍ A PEU", "ogr")
                symbol_peu = QgsLineSymbol.createSimple({'line_style':'dash','color':'black','width':'0.6'})
                result.renderer().setSymbol(symbol_peu)
                result.triggerRepaint()
                self.dlg.progres.setValue(100)

                consulta = 'DROP TABLE temporal;'
                if query.exec_(consulta) == 0:
                    self.missatge(self.tr(u"Error en eliminar la taula temporal\n")+query.lastError().text())
                    return

                consulta = 'DROP TABLE bicing_aptes;'
                if query.exec_(consulta) == 0:
                    self.missatge(self.tr(u"Error en eliminar la taula bicing_aptes\n")+query.lastError().text())

                consulta = 'DROP TABLE jardins_aptes;'
                if query.exec_(consulta) == 0:
                    self.missatge(self.tr(u"Error en eliminar la taula jardins_aptes\n")+query.lastError().text())                
                
            except:
                self.dlg.progres.setValue(0)
                self.missatge(self.tr(u"No existeix una ruta possible. Possiblement el punt d'inici es troba a una zona d'altes emissions.\nProveu a canviar els paràmetres de contaminació."),'Error')

        if self.dlg.metode_transport.currentText() == 'En cotxe':
            try:
                totscamins = processing.run("native:shortestpathpointtolayer",{'DEFAULT_DIRECTION':2,'DEFAULT_SPEED':50,'DIRECTION_FIELD':'velocitat','END_POINTS':jardins,'INPUT':xarxa,'SPEED_FIELD':None,'START_POINT':punt_inici,'STRATEGY':0,'TOLERANCE':0,'VALUE_BACKWARD':'','VALUE_BOTH':'','VALUE_FORWARD':'','OUTPUT':'memory:Rutes'},feedback=feedback)['OUTPUT']
                #QgsProject.instance().addMapLayer(totscamins)
                db = self.conectadb()
                query = QSqlQuery(db)
                uri = "dbname='projectegis' host='localhost' port='5432' user='postgres' password='' key=id type=LINESTRING table=\"public\".\"temporal\" (geom) sql="
                error = QgsVectorLayerExporter.exportLayer(
                    totscamins,
                    uri,
                    "postgres",
                    QgsCoordinateReferenceSystem(),
                    False)

                self.dlg.progres.setValue(31)

                selmin = '(SELECT * FROM temporal WHERE cost = (SELECT MIN(cost) FROM temporal) LIMIT 1)'
                sql = selmin
                uri = QgsDataSourceUri()
                uri.setConnection(hostbd, str(portbd), nombd, usuaribd, contrasenyabd)
                uri.setDataSource("",sql,"geom","","id")
                cami_cotxe = QgsVectorLayer(uri.uri(),"cami_cotxe","postgres")

                self.dlg.progres.setValue(37)

                now = datetime.now()
                ct = now.strftime("%d%m%Y_%H%M%S")         
                _writer = QgsVectorFileWriter.writeAsVectorFormat(cami_cotxe, "C:/temp/camicotxe_"+ct+".shp",'utf-8',driverName='ESRI Shapefile')
                result = iface.addVectorLayer("C:/temp/camicotxe_"+ct+".shp", "CAMÍ EN COTXE", "ogr")
                symbol_cotxe = QgsLineSymbol.createSimple({'color':'black','width':'0.6'})
                result.renderer().setSymbol(symbol_cotxe)
                result.triggerRepaint()
                self.dlg.progres.setValue(100)

                consulta = 'DROP TABLE temporal;'
                if query.exec_(consulta) == 0:
                    self.missatge(self.tr(u"Error en eliminar la taula temporal\n")+query.lastError().text())
                    return

                consulta = 'DROP TABLE bicing_aptes;'
                if query.exec_(consulta) == 0:
                    self.missatge(self.tr(u"Error en eliminar la taula bicing_aptes\n")+query.lastError().text())

                consulta = 'DROP TABLE jardins_aptes;'
                if query.exec_(consulta) == 0:
                    self.missatge(self.tr(u"Error en eliminar la taula jardins_aptes\n")+query.lastError().text())                
                
            except:
                self.dlg.progres.setValue(0)
                self.missatge(self.tr(u"No existeix una ruta possible. Possiblement el punt d'inici es troba a una zona d'altes emissions.\nProveu a canviar els paràmetres de contaminació."),'Error')

                
